var ttypes = require("./gen-nodejs/user_types.js");
var logchain = require("./gen-nodejs/logchain.js");
var thrift = require('thrift');
var log4js = require('log4js');
var DEFAULT_PORT = 7000;
var DEFAULT_FLUSH_INTERVAL = 3000; //3s
var DEFAULT_FLUSH_COUNT = 200;
var DEFAULT_MAX_FLUSH_COUNT = 20000;
var DEFAULT_SOCKET_TIMEOUT = 5000;
var last_flush_time = +new Date();

LogClient = module.exports.LogClient = function(config) {
	var self = this;
	self._user = config.user;
	self._passwd = config.passwd;
	self._appid = null;
	self._host = null;
	self._port = null; 
	self._logs_list = [];
	self._connected = false;
	var secretEntry_options = {
		"user": self._user,
		"passwd": self._passwd
	};
	self._secretEntry = new ttypes.SecretEntry(secretEntry_options);
	get_env(self);
	var connect_options = {
		"transport": thrift.TFramedTransport
	};
	self._connection = thrift.createConnection(self._host, self._port, connect_options);

	self._client = thrift.createClient(logchain, self._connection);
	self._connection.on('connect', function(){
		self._connected = true;
	});
	self._connection.on('close', function(){
		self._connected = false;
		self._connection.end();
		console.error("baelog server closed");
    });
	self._connection.on('error', function(err) {
		self._connected = false;
		console.error(err);
		self._connection.end();
	});
}

LogClient.prototype = {};

function get_env(self) {
	self._appid = process.env.BAE_ENV_APPID;
	self._host = process.env.BAE_ENV_LOG_HOST;
	self._port = process.env.BAE_ENV_LOG_PORT;
	if ( self._appid === undefined || self._host === undefined || self._port === undefined ) {
		console.log("Please don't use baelog outside BAE V3 environment");
		throw new Error("Please don't use baelog outside BAE V3 environment");
		self._ok = false;
		return;
	}
	self._ok = true;
}

LogClient.prototype.end = function() {
	var self = this;
	self.flush();
	self._logs_list =[];
	self._connection.end();
}
LogClient.prototype.flush = function() {
	var self = this;
	var msgs = [];
	for (var i=0;i<self._logs_list.length;i++) {
		msgs[i] = self._logs_list[i];
	}
	
	if (self._connected === false) {
		var connect_options = {
			"timeout": DEFAULT_SOCKET_TIMEOUT,
			"transport": thrift.TFramedTransport
		};
		self._connection = thrift.createConnection(self._host, self._port, connect_options);

		self._client = thrift.createClient(logchain, self._connection);
		self._connection.on('connect', function(){
			self._connected = true;
		});
		self._connection.on('close', function(){
			self._connected = false;
			self._connection.end();
			console.error("baelog server closed");
    	});
		self._connection.on('error', function(err) {
			if (msgs.length + self._logs_list.length < DEFAULT_MAX_FLUSH_COUNT) {
				for (var i=0;i<msgs.length;i++){
					self._logs_list.push(msgs[i]);
				}
			}
			self._connected = false;
			console.error(err);
			self._connection.end();
		});
	}
	var times = 3;
	sendtobae(msgs);
	function sendtobae(msgs) {
		if (times <= 0) {
			return;
		}
		var baelog_args = {
			"secret":  self._secretEntry,
			"messages": msgs
		};
		var baeLog = new ttypes.BaeLog(baelog_args);
		self._client.log(baeLog,function(err,data){
			if (err) {
				if (times > 0) {
					times--;
					sendtobae(msgs);
				} else {
					if (msgs.length + self._logs_list.length < DEFAULT_MAX_FLUSH_COUNT) {
						for (var i=0;i<msgs.length;i++){
							self._logs_list.push(msgs[i]);
						}
					}
					console.error(err);	
				}
			} else {
				times = 0;
				ret = data;
				if (ret === ttypes.BaeRet.OK) {
					msgs=[];
				} else {
					if (msgs.length + self._logs_list.length < DEFAULT_MAX_FLUSH_COUNT) {
						for (var i=0;i<msgs.length;i++){
							self._logs_list.push(msgs[i]);
						}
					}
					console.error("baeLog error, return is " + ret);
				}
        	}
		});	
	}
	
}

LogClient.prototype.log = function(loggingEvent) {
	var self = this;
	if (self._ok === false) {
		console.log("BaeLog env error");
		return;
	}
	var loglevel = null;
	switch(loggingEvent.level) {
		case log4js.levels.OFF:
		case log4js.levels.FATAL: 
		case log4js.levels.ERROR:
			loglevel = ttypes.BaeLogLevel['FATAL'];
			break;
		case log4js.levels.WARN:
			loglevel = ttypes.BaeLogLevel['WARNING'];
			break;
		case log4js.levels.INFO:
			loglevel = ttypes.BaeLogLevel['NOTICE'];
			break;
		case log4js.levels.DEBUG:
			loglevel = ttypes.BaeLogLevel['DEBUG'];
			break;
		case log4js.levels.TRACE:
			loglevel = ttypes.BaeLogLevel['TRACE'];
			break;
		case log4js.levels.ALL:
			loglevel = ttypes.BaeLogLevel['DEBUG'];
			break;
		default:
			loglevel = ttypes.BaeLogLevel['NOTICE'];
	}
	var user_args = {
		"appid": self._appid,
		"level": loglevel,
		"msg": loggingEvent.data[0],
		"timestamp": +new Date(),
		"tag": loggingEvent.categoryName
	};

	var buffer = "";
	var userLogEntry = new ttypes.UserLogEntry(user_args);
	var transport = new thrift.TBufferedTransport(buffer,function(msg) {
		var baelog_args = {
			"category": "user",
			"content": msg
		};

		var baeLogEntry = new ttypes.BaeLogEntry(baelog_args);
		self._logs_list.push(baeLogEntry);

		var now = +new Date();
        if ( (now - last_flush_time) >= DEFAULT_FLUSH_INTERVAL
                || self._logs_list.length >= DEFAULT_FLUSH_COUNT) {
			self.flush();
			self._logs_list=[];
			last_flush_time = now;
		}
	});
	var protocol = new thrift.TBinaryProtocol(transport);
	userLogEntry.write(protocol);
	protocol.flush();
}
